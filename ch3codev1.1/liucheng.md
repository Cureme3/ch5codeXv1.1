总体数据流（顶层）
[故障工况设定]
      │
      ▼
[动力学仿真 + 故障注入]
( simulate_ecifull / FaultGenerator )
      │
      ▼
[传感器测量信号 a_meas(t)]
(含噪声、含故障效应)
      │
      ▼
[ESO 残差生成]
( run_eso → 残差 r(t), 扩展扰动 d(t) )
      │
      ├─────────────┬──────────────┐
      ▼             ▼              ▼
  [线 A]          [线 B]         [线 C]
  残差/时频图     特征样本      阈值检测

线 A：残差曲线 & 时频图像的生成
A1. 残差时域图（图 3-1 / 图 3-2）
[故障工况集合 {F0~F5}]
      │
      ▼
[循环遍历每个工况]
  for each fault case:
      │
      ▼
[动力学仿真]
( FaultGenerator.simulate(...) )
      │
      ▼
[得到测量加速度 a_meas(t)]
      │
      ▼
[ESO 观测器]
( run_eso(a_meas[:, [0,2]], dt) )
      │
      ▼
[残差序列 r_pred(t) = y_meas - y_pred]
( 取其中一通道，如 z 向 r_z(t) )
      │
      ▼
[残差随时间绘图]
( 多子图比较名义与不同故障工况 )
      │
      ▼
→ 生成：图 3-1 / 图 3-2 残差时域曲线

A2. 残差时频图（STFT / PWVD，图 3-3 等）
[选定某一工况的残差 r(t)]
(通常是某种典型故障，或名义+故障对比)
      │
      ▼
[STFT 计算]
( r(t) ──STFT──► S_stft(f, τ) )
      │
      ▼
[幅度 → dB 尺度，时频平滑]
( |S| → 20 log10 |S|，再做 t/f 方向平滑 )
      │
      ▼
[绘制 STFT 时频图]
( imshow(S_dB) → “能量–频率–时间”图像 )
      │
      ▼
[（可选）PWVD 计算]
( r(t) ──PWVD──► S_pwvd(f, τ) 同样画图 )
      │
      ▼
→ 生成：图 3-3 等时频图（STFT / PWVD）


这一条线的所有数据都源于：仿真 → ESO → 残差 r(t)。
图像只是对残差“形状”的可视化，不直接参与训练。

线 B：特征样本 → 数据集 → 分类器训练（第三章“训练”主线）
[故障工况集合 {F0~F5} + Monte Carlo 抖动]
      │
      ▼
[批量仿真生成样本]
( scripts.make_dataset_cache / train_eval_classifier 内部 )
      │
      ▼
[对每个样本场景执行：]
  ┌──────────────────────────────────────┐
  │ 1) 动力学仿真                        │
  │    simulate_ecifull / FaultGenerator │
  │                                      │
  │ 2) 得到测量加速度 a_meas(t)          │
  │                                      │
  │ 3) ESO 计算残差 r(t)                 │
  │    run_eso(a_meas[:, [0,2]], dt)     │
  │                                      │
  │ 4) 从残差 r(t) 提取时频特征：        │
  │    - STFT：S(f, τ)                   │
  │      · 低频能量 e1                   │
  │      · 中频能量 e2                   │
  │      · 高频能量 e3                   │
  │    - 样本熵：SampEn(r(t)) = e4       │
  │                                      │
  │ 5) 形成单个特征向量 x = [e1, e2, e3, e4] │
  │    标签 y = 当前故障类型 (F0~F5)          │
  └──────────────────────────────────────┘
      │
      ▼
[堆叠得到训练数据集]
X ∈ ℝ^{N×4},  y ∈ {F0,…,F5}^N
( 保存为 dataset_Nxxx_seedxx.npz )
      │
      ▼
[分类器训练与验证]
( scripts.train_eval_classifier )
      │
      ▼
[分类模型 f(x)]
( 输出：故障类别以及概率/置信度 )
      │
      ▼
[性能评估 & 可视化]
  ├─ 混淆矩阵 (图 3-5)
  ├─ 准确率 / 召回率 / F1 曲线 (图 3-6)
  └─ 复杂度统计 (表 3-5 等)


在这一条链路里，“你生成的样本”指的就是上面这个 dataset_Nxxx_seedxx.npz：
大量故障仿真 + ESO 残差 + STFT+熵特征 ⇒ 特征矩阵 X 和标签 y。
训练脚本就是拿这些 npz 里的 X、y 做训练和评估。

线 C：基于残差的阈值检测（阈值法性能分析）
[残差序列 r(t)]
(同样来自：仿真 + ESO)
      │
      ▼
[滑动时间窗统计 / 能量指标]
( 在每个检测窗口上计算，如 rms, |r| 的积分 等 )
      │
      ▼
[与给定阈值 θ 比较]
  if  指标 > θ  → 判故障
      │
      ▼
[遍历不同阈值 θ ∈ Θ]
  统计：
  - 检测率 / 漏检率 (TPR / FNR)
  - 误检率 FPR
  - 检测时延等
      │
      ▼
[生成性能曲线与表格]
  ├─ 不同 θ 下 FPR/TPR 曲线（类似 ROC）
  ├─ 多故障类型下的检测性能对比
  └─ 表 3-4：阈值法检测性能统计
      │
      ▼
[单样本残差 + 阈值示意图]
( 图 3-7 / 3-8：在残差曲线上标出阈值与告警时刻 )